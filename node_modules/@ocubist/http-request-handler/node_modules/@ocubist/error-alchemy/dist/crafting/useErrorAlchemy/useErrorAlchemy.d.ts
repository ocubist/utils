/// <reference types="node" />
import z from "zod";
import { DetectorFunction, Transmuter, TransmuterFunction } from "../Transmuter/types";
import { Synthesizer, SynthesizerMiddlewareChain } from "../Synthesizer/types";
export declare const AlchemyCraftErrorProps: z.ZodObject<Omit<{
    name: z.ZodString;
    severity: z.ZodOptional<z.ZodEnum<[import("../..").Severity, ...import("../..").Severity[]]>>;
    cause: z.ZodOptional<z.ZodString>;
    module: z.ZodOptional<z.ZodString>;
    context: z.ZodOptional<z.ZodString>;
    errorCode: z.ZodOptional<z.ZodEnum<[import("../..").ErrorCode, ...import("../..").ErrorCode[]]>>;
}, "module" | "context">, "strip", z.ZodTypeAny, {
    name: string;
    severity?: import("../..").Severity | undefined;
    cause?: string | undefined;
    errorCode?: import("../..").ErrorCode | undefined;
}, {
    name: string;
    severity?: import("../..").Severity | undefined;
    cause?: string | undefined;
    errorCode?: import("../..").ErrorCode | undefined;
}>;
export type AlchemyCraftErrorProps = z.infer<typeof AlchemyCraftErrorProps>;
export declare const useErrorAlchemy: (module: string, context: string) => {
    craftErrorSynthesizer: (middlewareChain: SynthesizerMiddlewareChain) => Synthesizer;
    craftMysticError: (props: AlchemyCraftErrorProps) => {
        new (props: {
            message: string;
            origin?: unknown;
            payload?: Record<string, unknown> | undefined;
        }): {
            dynamicClassUuid: string;
            instanceUuid: string;
            name: string;
            severity: import("../..").Severity;
            origin?: unknown;
            cause?: string | undefined;
            payload: Record<string, unknown>;
            module?: string | undefined;
            context?: string | undefined;
            errorCode: import("../..").ErrorCode;
            readonly severityDescription: string;
            readonly simpleGetter: string;
            readonly identifier: string;
            message: string;
            stack?: string | undefined;
        };
        compare(err: unknown): boolean;
        captureStackTrace(targetObject: object, constructorOpt?: Function | undefined): void;
        prepareStackTrace?: ((err: Error, stackTraces: NodeJS.CallSite[]) => any) | undefined;
        stackTraceLimit: number;
    };
    craftSynthesizedError: (props: AlchemyCraftErrorProps) => {
        new (props: {
            message: string;
            origin?: unknown;
            payload?: Record<string, unknown> | undefined;
        }): {
            dynamicClassUuid: string;
            instanceUuid: string;
            name: string;
            severity: import("../..").Severity;
            origin?: unknown;
            cause?: string | undefined;
            payload: Record<string, unknown>;
            module?: string | undefined;
            context?: string | undefined;
            errorCode: import("../..").ErrorCode;
            readonly severityDescription: string;
            readonly simpleGetter: string;
            readonly identifier: string;
            message: string;
            stack?: string | undefined;
        };
        compare(err: unknown): boolean;
        captureStackTrace(targetObject: object, constructorOpt?: Function | undefined): void;
        prepareStackTrace?: ((err: Error, stackTraces: NodeJS.CallSite[]) => any) | undefined;
        stackTraceLimit: number;
    };
    craftErrorTransmuter: <T = any>(detectorFunction: DetectorFunction, transmuterFunction: TransmuterFunction<T>) => Transmuter<T>;
    craftErrorLogger: (props: import("../Resolver/craftErrorLogger").CraftErrorLoggerProps) => (err: unknown) => void;
    craftErrorResolverMap: (...mapping: [typeof import("../..").SynthesizedError, (err: import("../..").SynthesizedError) => void][]) => Map<typeof import("../..").SynthesizedError, (err: import("../..").SynthesizedError) => void>;
    craftErrorResolver: (props: import("../Resolver/craftErrorResolver").CraftErrorResolverProps) => (err: unknown) => void;
};
//# sourceMappingURL=useErrorAlchemy.d.ts.map